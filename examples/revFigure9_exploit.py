import numpy as np
from PUQ.prior import prior_dist
from PUQ.utils import parse_arguments
from PUQ.design import designer
from test_funcs import bimodal, banana, unimodal
from utilities import test_data_gen, twoD, heatmap
from scipy.stats import linregress
import matplotlib.pyplot as plt

args = parse_arguments()

# # # # # 
args.funcname = 'bimodal'
args.seedmin = 0
args.seedmax = 10
repres = args.seedmax - args.seedmin
# # # # # 

grid = 10
rep0 = 2
nmesh = 50
rho = 1/2

maxiter = 320
time_dict = []
if __name__ == "__main__":
    
    for batch in [8, 16, 32, 64]:
        workers = batch + 1
        for s in np.arange(args.seedmin, args.seedmax):
            
            cls_func = eval(args.funcname)()
            cls_func.realdata(seed=s)
    
            theta_test, p_test, f_test, Xpl, Ypl = test_data_gen(cls_func, nmesh)
            test_data = {"theta": theta_test, "f": f_test, "p": p_test, "p_prior": 1}
    
            # heatmap(cls_func)
        
            # Set a uniform prior
            prior_func = prior_dist(dist="uniform")(
                a=cls_func.thetalimits[:, 0], b=cls_func.thetalimits[:, 1]
            )
            
            # Set random stream for initial design
            persis_info = {'rand_stream': np.random.default_rng(s)}
    
            # Initial sample
            theta1 = np.linspace(cls_func.thetalimits[0][0], cls_func.thetalimits[0][1], grid)
            theta2 = np.linspace(cls_func.thetalimits[1][0], cls_func.thetalimits[1][1], grid)
            th1, th2 = np.meshgrid(theta1, theta2)
            theta0u = np.vstack([th1.ravel(), th2.ravel()]).T
            theta0 = np.repeat(theta0u, rep0, axis=0)
            f0     = np.zeros((cls_func.d, rep0*(grid**2)))
            for i in range(0, rep0*(grid**2)):
                f0[:, i] = cls_func.sim_f(theta0[i, :], persis_info=persis_info)
    
            al_ivar = designer(
                data_cls=cls_func,
                method="p_sto_bseq",
                acquisition="seivar",
                args={
                    "prior": prior_func,
                    "data_test": test_data,
                    "max_iter": maxiter,
                    "nworkers": workers,
                    "batch_size": batch,
                    "des_init":{'seed':s, 'theta':theta0, 'f':f0},
                    "alloc_settings":{'method':'ivar', 'use_Ki':True, 'rho': rho, 'theta':None, 'a0':None, 'gen':False},
                    "pc_settings":{'standardize':True, 'latent':False},
                    "des_settings":{'is_exploit':True, 'is_explore':False}
                },
            )
            
            # twoD(al_ivar, Xpl, Ypl, p_test, nmesh)
            
            time = [t for t in al_ivar._info['time']]
            
            time_dict.append({'time': time, 'rep': s, 'batch': batch})
        
    # Process data to compute average arrays for each batch
    batch_averages = {}
    for entry in time_dict:
        batch = entry['batch']
        time_array = np.array(entry['time'])
        if batch not in batch_averages:
            batch_averages[batch] = []
        batch_averages[batch].append(time_array)
    
    # Compute average for each batch
    result = {batch: np.mean(np.array(times), axis=0) for batch, times in batch_averages.items()}
    resultsd = {batch: np.std(np.array(times), axis=0)/np.sqrt(repres) for batch, times in batch_averages.items()}
    cs = ['blue', 'red', 'green', 'cyan']
    ms = ['^', '*', 'o', 'D']
    fig, ax = plt.subplots(1, 1, figsize=(8, 6))
    ft = 20
    idc = 0

    for batch, avg_times in result.items():
        xlm = np.arange(1, len(avg_times) + 1)
        ylm = avg_times
        yerr = resultsd[batch]
        
        # Fit a linear regression model to the data
        slope, intercept, r_value, p_value, std_err = linregress(xlm, ylm)
        trend_line = slope * xlm + intercept
   
        ax.scatter(xlm, ylm, marker=ms[idc], color=cs[idc], label=str(batch), s=100)
        # Plot scatter points with error bars
        ax.errorbar(xlm, ylm, yerr=yerr, fmt=ms[idc], color=cs[idc],
                    label=str(batch), capsize=5, markersize=10)




        # ax.plot(xlm, trend_line, color=cs[idc], linestyle='--', linewidth=2)
        
        # Calculate total time and add annotation
        total_time = np.sum(ylm)
        ax.annotate(f'{total_time:.0f}', 
                    xy=(xlm[-1], ylm[-1]), xycoords='data', 
                    xytext=(10, 10), textcoords='offset points',
                    fontsize=ft-5, color=cs[idc])

        idc += 1
    ax.set_xlabel('t', fontsize=ft)
    ax.set_ylabel('Time (sec.)', fontsize=ft)   
    ax.tick_params(axis="both", labelsize=ft)
    ax.legend(loc = 'lower center', bbox_to_anchor = (0.5, -0.3),
              fancybox = True, shadow = True, ncol = 4, fontsize=ft-5)
    plt.savefig('time_exploit.png', bbox_inches='tight')
    plt.show()

# all_data = [batch_averages[key] for key in batch_averages]
# import seaborn as sns

# fig, ax = plt.subplots(1, 1, figsize=(12, 6))
# sns.boxplot(pd.DataFrame(batch_averages[8]), color='lightblue')
# sns.boxplot(pd.DataFrame(batch_averages[16]), color='lightgreen')
# sns.boxplot(pd.DataFrame(batch_averages[32]), color='lightcoral')
# sns.boxplot(pd.DataFrame(batch_averages[64]), color='purple')